using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Naive.Console;
using Naive.HttpSvr;
using System.Security.Cryptography;
using System.Threading;
using System.Net;
using System.Text;

namespace NaiveSocks
{
    public class Commands
    {
        public static void loadController(Controller c, string configFilePath)
        {
            c.LoadConfigFileOrWarning(configFilePath);
            c.Start();
        }

        public static void NewbieWizard(Command cmd, Controller c, string configFilePath)
        {
            cmd.Console.Write($"** Naive Setup Wizard **\n\n", ConsoleColor.White);
            var template = cmd.Select("This is:", new Dictionary<string, Func<string>> {
                ["Client"] = () => {
                    var server = cmd.ReadLine("Server addr:port (e.g., baidu.com:80): ");
                    var serverPath = cmd.ReadLine("Server path", "/");
                    var key = cmd.ReadLine("Server key: ");
                    var socks5port = cmd.ReadLine("Local socks5 listening port", "1080");
                    var config = new {
                        @in = new {
                            socks5in = new {
                                type = "socks5",
                                local = "127.1:" + socks5port,
                                @out = "naiveclient"
                            }
                        },
                        @out = new {
                            naiveclient = new {
                                type = "naive",
                                server = server,
                                path = serverPath,
                                key = key
                            }
                        }
                    };
                    return Nett.Toml.WriteString(config);
                },
                ["Server"] = () => {
                    var serverPort = cmd.ReadLine("Server listening port", "8080");
                    var serverPath = cmd.ReadLine("Server path (e.g. /updatews)", "/");
                    var key = cmd.ReadLine("Server key: ");
                    var config = new {
                        @in = new {
                            newbie_server = new {
                                type = "naive",
                                local = "0:" + serverPort,
                                path = serverPath,
                                key = key,
                                @out = "direct"
                            }
                        },
                        @out = new {
                            direct = new {
                                type = "direct"
                            }
                        }
                    };
                    return Nett.Toml.WriteString(config);
                },
            }, loopUntilSelect: false);
            if (template == null)
                return;
            var str = "## Generated by Naive Setup Wizard\n\n" + template() + "\n## End of File\n";
            cmd.WriteLine(str);
            cmd.WriteLine("Configration generated.");
            if (cmd.YesOrNo($"Save to '{configFilePath}'?", true)) {
                if (File.Exists(configFilePath)
                    && !cmd.YesOrNo($"But '{configFilePath}' already exists, override?", false)) {
                    return;
                }
                File.WriteAllText(configFilePath, str, NaiveUtils.UTF8Encoding);
                cmd.WriteLine("Saved.");
                if (cmd.YesOrNo("Reload now?", true)) {
                    c.Reload();
                }
            }
        }

        public static void AddCommands(CommandHub cmdHub, Controller controller, string prefix)
        {
            cmdHub.AddCmdHandler(prefix + "c", command => {
                var con = command.Console;
                var arr = controller.InConnections.ToArray();
                var sb = new StringBuilder(64);
                foreach (var item in arr) {
                    if (item.IsHandled) {
                        sb.Clear();
                        item.ToString(sb, InConnection.ToStringFlags.Default & ~InConnection.ToStringFlags.Bytes & ~InConnection.ToStringFlags.AdditionFields & ~InConnection.ToStringFlags.OutAdapter);
                        command.Write(sb.ToString());
                        if (item.ConnectResult?.Adapter != null) {
                            con.Write(" -> '" + item.ConnectResult.Adapter.Name + "'", ConsoleColor.Cyan);
                        }
                        var rw = item.BytesCountersRW;
                        con.Write("\n R=" + rw.R, ConsoleColor.Green);
                        con.Write(" W=" + rw.W + " ", ConsoleColor.Yellow);
                        con.Write(item.GetInfoStr() + "\n", ConsoleColor.DarkGray);
                    } else {
                        command.Console.Write(item + "\n", ConsoleColor.Yellow);
                    }
                }
                command.WriteLine($"({arr.Length} connections)");
            });
            cmdHub.AddCmdHandler(prefix + "wsc", (cmd) => {
                cmd.WriteLine($"# managed websocket connections ({WebSocket.ManagedWebSockets.Count}): ");
                var curTime = WebSocket.CurrentTime;
                foreach (var item in WebSocket.ManagedWebSockets.ToArray()) {
                    cmd.WriteLine($"{item} LatestActive/StartTime={item.LatestActiveTime - curTime}/{item.CreateTime - curTime}");
                }
            });
            cmdHub.AddCmdHandler(prefix + "reload", command => {
                if (command.args.Length == 0) {
                    controller.Reload();
                } else if (command.args.Length == 1) {
                    controller.LoadConfigFileOrWarning(command.args[0], false);
                    controller.Reload();
                } else {
                    command.WriteLine("wrong arguments");
                }
            }, "Usage: reload [NEW_FILE]");
            cmdHub.AddCmdHandler(prefix + "stat", command => {
                var proc = Process.GetCurrentProcess();
                command.WriteLine($"TotalMemory: {GC.GetTotalMemory(command.args.Contains("gc")).ToString("N0")}");
                command.WriteLine("CollectionCount: " + string.Join(
                    ", ",
                    Enumerable.Range(0, GC.MaxGeneration + 1)
                        .Select(x => $"({x}) {GC.CollectionCount(x)}")));
                command.WriteLine($"WorkingSet: {proc.WorkingSet64.ToString("N0")}");
                command.WriteLine($"PrivateMemory: {proc.PrivateMemorySize64.ToString("N0")}");
                command.WriteLine($"CPUTime: {proc.TotalProcessorTime.TotalMilliseconds.ToString("N0")} ms");
                ThreadPool.GetMinThreads(out var workersMin, out var portsMin);
                ThreadPool.GetMaxThreads(out var workersMax, out var portsMax);
                command.WriteLine($"Threads: {proc.Threads.Count} (workers: {workersMin}-{workersMax}, ports: {portsMin}-{portsMax})");
                command.WriteLine($"Connections: {controller.RunningConnections:N0} running, {controller.TotalHandledConnections} handled");
                command.WriteLine($"MyStream Copied: {MyStream.TotalCopiedPackets:N0} packets, {MyStream.TotalCopiedBytes:N0} bytes");
                command.WriteLine($"SocketStream1: {SocketStream1.GlobalCounters.StringRead};");
                command.WriteLine($"               {SocketStream1.GlobalCounters.StringWrite}.");
            });
            cmdHub.AddCmdHandler(prefix + "config", c => {
                var con = c.Console;
                var cfg = controller.CurrentConfig;
                c.WriteLine("# Current configuration:");
                c.WriteLine();
                c.WriteLine("  File Path: " + cfg.FilePath);
                if (cfg.FilePath == null || Path.GetDirectoryName(cfg.FilePath) != cfg.WorkingDirectory) {
                    c.WriteLine("  Working Directory: " + cfg.WorkingDirectory);
                }
                c.WriteLine("  Logging Level: " + cfg.LoggingLevel);
                c.WriteLine();
                var inadas = cfg.InAdapters.ToArray();
                Array.Sort(inadas, (a, b) => {
                    return -a.BytesCountersRW.TotalValue.Bytes.CompareTo(b.BytesCountersRW.TotalValue.Bytes);
                });
                c.WriteLine($"  ## InAdapters ({inadas.Length}):");
                foreach (var item in inadas) {
                    var str = $"    - '{item.Name}': {item.ToString(false)} -> {item.@out?.ToString() ?? "(No OutAdapter)"}";
                    var rw = item.BytesCountersRW;
                    if (rw.TotalValue.Packets == 0) {
                        con.WriteLine(str);
                    } else {
                        con.Write(str);
                        con.Write(" R=" + rw.R, ConsoleColor.Green);
                        con.Write(" W=" + rw.W + "\n", ConsoleColor.Yellow);
                    }
                }
                c.WriteLine();
                var outadas = cfg.OutAdapters.ToArray();
                Array.Sort(outadas, (a, b) => {
                    return -a.BytesCountersRW.TotalValue.Bytes.CompareTo(b.BytesCountersRW.TotalValue.Bytes);
                });
                c.WriteLine($"  ## OutAdapters ({outadas.Length}):");
                foreach (var item in outadas) {
                    var str = $"    - '{item.Name}': {item.ToString(false)}";
                    var rw = item.BytesCountersRW;
                    if (rw.TotalValue.Packets == 0) {
                        con.WriteLine(str);
                    } else {
                        con.Write(str);
                        con.Write(" R=" + rw.R, ConsoleColor.Green);
                        con.Write(" W=" + rw.W + "\n", ConsoleColor.Yellow);
                    }
                }
            });
            cmdHub.AddCmdHandler(prefix + "logs", command => {
                var cmd = command.ArgOrNull(0);
                if (cmd == "dump") {
                    var logs = Logging.getLogsHistoryArray();
                    var path = command.ArgOrNull(1);
                    if (path == null) {
                        command.WriteLine("missing path.");
                        return;
                    }
                    using (var sw = new StreamWriter(
                        File.Open(path, FileMode.Create, FileAccess.ReadWrite, FileShare.ReadWrite),
                        NaiveUtils.UTF8Encoding, 8192)) {
                        foreach (var item in logs) {
                            sw.Write(item.timestamp);
                            sw.Write(item.text);
                            sw.WriteLine();
                        }
                    }
                } else if (cmd == "show") {
                    Logging.Log[] logs;
                    if (command.ArgOrNull(1) == null) {
                        logs = Logging.getLogsHistoryArray();
                    } else {
                        var count = int.Parse(command.ArgOrNull(1));
                        logs = new Logging.Log[count];
                        Logging.getLogsHistory(new ArraySegment<Logging.Log>(logs));
                    }
                    PrintLogs(command.Console, logs);
                } else if (cmd == "test") {
                    var strs = Enumerable.Range(1, 9).Select(x => new string((char)('0' + x), x)).ToArray();
                    for (int i = 0; i < 10_000; i++) {
                        int num = NaiveUtils.Random.Next(0, 9);
                        Logging.log(strs[num], Logging.Level.Debug);
                    }
                } else {
                    command.WriteLine("wrong arguments.");
                }
            }, "Usage: logs (dump PATH)|show");
            cmdHub.AddCmdHandler(prefix + "gc", command => {
                NaiveUtils.GCCollect(command.WriteLine);
            });
            cmdHub.AddCmdHandler(prefix + "test", cmd => {
                cmd.WriteLine($"Stopwatch.Frequency: {Stopwatch.Frequency}");
                cmd.WriteLine($"Stopwatch.IsHighResolution: {Stopwatch.IsHighResolution}");
                cmd.WriteLine($"Environment.ProcessorCount: {pcount}");
                var selections = tests.Select(x => x.Name).ToList();
                var all = "ALL tests with '*'";
                selections.Insert(0, all);
                while (true) {
                    var index = cmd.Select("Selete a performance test:", selections, "(input other text to exit): ", false);
                    if (index < 0) {
                        return;
                    } else if (index == 0) {
                        foreach (var item in tests) {
                            if (item.Name.StartsWith("*"))
                                item.Run(cmd.Console);
                        }
                    } else {
                        tests[index - 1].Run(cmd.Console);
                    }
                    cmd.WriteLine("");
                }
            });
            cmdHub.AddCmdHandler(prefix + "mdebug", (cmd) => {
                Channel.Debug ^= true;
                cmd.WriteLine($"Multiplexing debugging is now set to {Channel.Debug}");
            });
            cmdHub.AddCmdHandler(prefix + "mping", (cmd) => {
                var keep = true;
                var pingEnabled = false;
                switch (cmd.ArgOrNull(0)) {
                case "start":
                    pingEnabled = true;
                    break;
                case "stop":
                    pingEnabled = false;
                    break;
                case null:
                    keep = false;
                    break;
                default:
                    cmd.WriteLine($"wrong argument '{cmd.ArgOrNull(0)}'");
                    cmd.statusCode = 1;
                    return;
                }
                if (keep) {
                    cmd.WriteLine(pingEnabled ? "start ping" : "stop ping");
                }
                List<Task> tasks = new List<Task>();
                var outs = from x in controller.OutAdapters where x is NaiveMOutAdapter select (x as NaiveMOutAdapter);
                if (keep) {
                    foreach (var item in outs) {
                        item.ping_enabled = pingEnabled;
                    }
                    return;
                }
                var ins = from x in controller.InAdapters where x is NaiveMServerBase select x.As<NaiveMServerBase>().nmsList;
                foreach (IEnumerable<NaiveMChannels> item in (from x in outs select from y in x.ncsPool select y.nms).Union(ins)) {
                    foreach (var poolItem in item) {
                        var task = NaiveUtils.RunAsyncTask(async () => {
                            try {
                                await (poolItem?.Ping((t) => cmd.WriteLine($"{poolItem.BaseChannels}: {t}"), true)).NoNRE();
                            } catch (Exception e) {
                                cmd.WriteLine(Logging.getExceptionText(e, $"{poolItem?.BaseChannels} pinging"));
                            }
                        });
                        tasks.Add(task);
                    }
                }
                if (Task.WhenAll(tasks.ToArray()).WithTimeout(3 * 1000).Wait()) {
                    cmd.WriteLine($"waiting timed out.");
                }
            }, "Usage: mping [start|stop]");
            cmdHub.AddCmdHandler(prefix + "settp", cmd => {
                ThreadPool.SetMinThreads(cmd.ArgOrNull(0).ToInt(), cmd.ArgOrNull(1).ToInt());
                ThreadPool.SetMaxThreads(cmd.ArgOrNull(2).ToInt(), cmd.ArgOrNull(3).ToInt());
            }, "workerMin portMin workerMax portMax");
        }

        static byte[] sampleKey(int bytesCount) => NaiveProtocol.GetRealKeyFromString("testtttt", bytesCount);
        static byte[] sampleIV(int bytesCount, byte b = 0x80) => Enumerable.Range(0, bytesCount).Select(x => b).ToArray();
        static int pcount = Environment.ProcessorCount;

        struct TestCtx
        {
            public Stopwatch sw;
        }

        class TestItem
        {
            public string Name;
            public Action<TestCtx> Action;

            public TestItem(string name, Action<TestCtx> action)
            {
                Name = name;
                Action = action;
            }

            public void Run(CmdConsole con)
            {
                con.Write(Name, Color32.FromConsoleColor(ConsoleColor.Cyan));
                con.Write("...GC...");
                var sw = Stopwatch.StartNew();
                GC.Collect();
                try {
                    GC.WaitForFullGCComplete();
                } catch (Exception) {
                    con.Write("WaitGCFailed...");
                    Thread.Sleep(200);
                }
                sw.Stop();
                con.WriteLine(sw.ElapsedTicks + " ticks.");
                con.Write("Running...");
                sw.Restart();
                Action(new TestCtx { sw = sw });
                sw.Stop();
                con.Write("\tresult: ");
                con.Write($"[{sw.ElapsedMilliseconds:N0} ms]", Color32.FromConsoleColor(ConsoleColor.Green));
                con.WriteLine($", or {sw.ElapsedTicks:N0} ticks");
            }
        }

        static TestItem[] tests = new TestItem[] {
            new TestItem("alloc 32 KiB bytes 1024 times", (ctx) => {
                for (int i = 0; i < 1024; i++) {
                    var arr = new byte[32 * 1024];
                }
            }),
            new TestItem("alloc & copy 32 KiB bytes 1024 times", (ctx) => {
                var arr = new byte[32 * 1024];
                for (int i = 0; i < 1024; i++) {
                    NaiveUtils.CopyBytes(new byte[32 * 1024], 0, arr, 0, 32 * 1024);
                }
            }),
            new TestItem("* encrypt 3 bytes 1024 * 1024 times (ws filter - aes-128-ofb)", (ctx) => {
                var filter = WebSocket.GetAesStreamFilter(true, sampleKey(16));
                for (int i = 0; i < 1024 * 1024; i++) {
                    var buf = new byte[3];
                    var bv = new BytesView(buf);
                    filter(bv);
                }
            }),
            new TestItem("* encrypt 1024 bytes 16 * 1024 times (ws filter - aes-128-ofb)", (ctx) => {
                var filter = WebSocket.GetAesStreamFilter(true, sampleKey(16));
                for (int i = 0; i < 32 * 1024; i++) {
                    var buf = new byte[1024];
                    var bv = new BytesView(buf);
                    filter(bv);
                }
            }),
            new TestItem("* encrypt 32 KiB 512 times (ws filter - aes-128-ofb)", (ctx) => {
                var filter = WebSocket.GetAesStreamFilter(true, sampleKey(16));
                for (int i = 0; i < 512; i++) {
                    var buf = new byte[32 * 1024];
                    var bv = new BytesView(buf);
                    filter(bv);
                }
            }),
            new TestItem("* encrypt 128 KiB 128 times (aes-128-ctr)", (ctx) => {
                var provider = new AesCryptoServiceProvider();
                provider.Mode = CipherMode.ECB;
                provider.Padding = PaddingMode.None;
                provider.KeySize = 128;
                provider.Key = sampleKey(16);
                var ch = new CtrEncryptor(provider.CreateEncryptor());
                ch.IV = sampleIV(16);
                var buf = new byte[128 * 1024];
                var bv = new BytesSegment(buf);
                for (int i = 0; i < 128; i++) {
                    ch.Update(bv);
                }
            }),
            new TestItem("* encrypt 128 KiB 128 times (aes-128-cfb)", (ctx) => {
                var provider = new AesCryptoServiceProvider();
                provider.Mode = CipherMode.ECB;
                provider.Padding = PaddingMode.None;
                provider.KeySize = 128;
                provider.Key = sampleKey(16);
                var ch = new CfbEncryptor(provider.CreateEncryptor(), true);
                ch.IV = sampleIV(16);
                var buf = new byte[128 * 1024];
                var bv = new BytesSegment(buf);
                for (int i = 0; i < 128; i++) {
                    ch.Update(bv);
                }
            }),
            new TestItem("* encrypt 128 KiB 128 times (chacha20-ietf)", (ctx) => {
                var ch = new ChaCha20IetfEncryptor(sampleKey(32));
                ch.IV = sampleIV(12);
                var buf = new byte[128 * 1024];
                var bv = new BytesSegment(buf);
                for (int i = 0; i < 128; i++) {
                    ch.Update(bv);
                }
            }),
            new TestItem("* encrypt 128 KiB 128 times ('speck0' (speck-128/128-ctr) without multi-threading)", (ctx) => {
                Speck0Test(sampleKey(16), 128 * 1024, 128, false);
            }),
            new TestItem("encrypt 128 KiB 128 times ('speck0' (speck-128/128-ctr))", (ctx) => {
                Speck0Test(sampleKey(16), 128 * 1024, 128, true);
            }),
            new TestItem("* encrypt 16 KiB 1024 times ('speck0' (speck-128/128-ctr) without multi-threading)", (ctx) => {
                Speck0Test(sampleKey(16), 16 * 1024, 1024, false);
            }),
            new TestItem("encrypt 16 KiB 1024 times ('speck0' (speck-128/128-ctr))", (ctx) => {
                Speck0Test(sampleKey(16), 16 * 1024, 1024, true);
            }),
            new TestItem("encrypt 3 B 1024 * 1024 times ('speck0' (speck-128/128-ctr))", (ctx) => {
                Speck0Test(sampleKey(16), 3, 1024 * 1024, true);
            }),
            new TestItem("* encrypt 128 KiB 128 times ('speck064' (speck-64/128-ctr))", (ctx) => {
                var ch = new Speck.Ctr64128(sampleKey(16));
                ch.IV = sampleIV(8);
                var buf = new byte[128 * 1024];
                var bv = new BytesSegment(buf);
                for (int i = 0; i < 128; i++) {
                    ch.Update(bv);
                }
            }),
            new TestItem("* localhost socket 1", (ctx) => {
                var ep = new IPEndPoint(IPAddress.Loopback, NaiveUtils.Random.Next(20000, 60000));
                var listener = new Listener(ep) { LogInfo = false };
                listener.Accepted += (x) => NaiveUtils.RunAsyncTask(async () => {
                    var stream = new SocketStream1(x.Client);
                    var buf = new byte[32 * 1024];
                    while (await stream.ReadAsync(buf) > 0) {
                    }
                    x.Close();
                });
                listener.Run().Forget();
                TestSocketWrite(ctx.sw, ep, 32 * 1024, 1024);
                listener.Stop();
            }),
            new TestItem("localhost socket 1 (4 bytes read buffer)", (ctx) => {
                var ep = new IPEndPoint(IPAddress.Loopback, NaiveUtils.Random.Next(20000, 60000));
                var listener = new Listener(ep) { LogInfo = false };
                listener.Accepted += (x) => NaiveUtils.RunAsyncTask(async () => {
                    var stream = new SocketStream1(x.Client);
                    var buf = new byte[4];
                    while (await stream.ReadAsync(buf) > 0) {
                    }
                    x.Close();
                });
                listener.Run().Forget();
                TestSocketWrite(ctx.sw, ep, 32 * 1024, 1024);
                listener.Stop();
            }),
            new TestItem("localhost socket 1 (4 bytes read buffer without smart buffer)", (ctx) => {
                var ep = new IPEndPoint(IPAddress.Loopback, NaiveUtils.Random.Next(20000, 60000));
                var listener = new Listener(ep) { LogInfo = false };
                listener.Accepted += (x) => NaiveUtils.RunAsyncTask(async () => {
                    var stream = new SocketStream1(x.Client);
                    stream.EnableSmartReadBuffer = false;
                    var buf = new byte[4];
                    while (await stream.ReadAsync(buf) > 0) {
                    }
                    x.Close();
                });
                listener.Run().Forget();
                TestSocketWrite(ctx.sw, ep, 32 * 1024, 1024);
                listener.Stop();
            }),
            new TestItem("localhost socket 1 (4 bytes read buffer without smart buffer/sync)", (ctx) => {
                var ep = new IPEndPoint(IPAddress.Loopback, NaiveUtils.Random.Next(20000, 60000));
                var listener = new Listener(ep) { LogInfo = false };
                listener.Accepted += (x) => NaiveUtils.RunAsyncTask(async () => {
                    var stream = new SocketStream1(x.Client);
                    stream.EnableSmartReadBuffer = false;
                    stream.EnableSmartSyncRead = false;
                    var buf = new byte[4];
                    while (await stream.ReadAsync(buf) > 0) {
                    }
                    x.Close();
                });
                listener.Run().Forget();
                TestSocketWrite(ctx.sw, ep, 32 * 1024, 1024);
                listener.Stop();
            }),
            new TestItem("localhost socket 2", (ctx) => {
                var ep = new IPEndPoint(IPAddress.Loopback, NaiveUtils.Random.Next(20000, 60000));
                var listener = new Listener(ep) { LogInfo = false };
                listener.Accepted += (x) => NaiveUtils.RunAsyncTask(async () => {
                    var stream = new SocketStream2(x.Client);
                    var buf = new byte[32 * 1024];
                    while (await stream.ReadAsync(buf) > 0) {
                    }
                    x.Close();
                });
                listener.Run().Forget();
                NaiveUtils.RunAsyncTask(async () => {
                    var socket = await NaiveUtils.ConnectTcpAsync(AddrPort.Parse(ep.ToString()), 5000);
                    var stream = new SocketStream2(socket);
                    ctx.sw.Restart();
                    var buf = new byte[32 * 1024];
                    for (int i = 0; i < 1024; i++) {
                        await stream.WriteAsync(buf);
                    }
                    socket.Close();
                }).RunSync();
                listener.Stop();
            }),
            new TestItem("localhost socket 1 sync", (ctx) => {
                var ep = new IPEndPoint(IPAddress.Loopback, NaiveUtils.Random.Next(50000, 60000));
                var listener = new Listener(ep) { LogInfo = false };
                listener.Accepted += (x) => {
                    var stream = new SocketStream1(x.Client);
                    var buf = new byte[32 * 1024];
                    while (stream.Read(buf) > 0) {
                    }
                    x.Close();
                };
                listener.Run().Forget();
                {
                    var socket = NaiveUtils.ConnectTcpAsync(AddrPort.Parse(ep.ToString()), 5000).RunSync();
                    var stream = new SocketStream1(socket);
                    ctx.sw.Restart();
                    var buf = new byte[32 * 1024];
                    for (int i = 0; i < 1024; i++) {
                        stream.Write(buf);
                    }
                    socket.Close();
                }
                listener.Stop();
            }),
            new TestItem("get DateTime.Now 1024 * 1024 times", (ctx) => {
                for (int i = 0; i < 1024 * 1024; i++) {
                    var now = DateTime.Now;
                }
            }),
        };

        private static void PrintLogs(CmdConsole con, Logging.Log[] logs)
        {
            foreach (var item in logs) {
                PrintLog(con, item);
            }
            con.ForegroundColor = ConsoleColor.Blue;
            con.WriteLine(
                "({logs.Length} logs)");
            con.ResetColor();
        }

        private static void PrintLog(CmdConsole con, Logging.Log item)
        {
            ConsoleColor color;
            switch (item.level) {
            default:
            case Logging.Level.None:
                color = ConsoleColor.Gray;
                break;
            case Logging.Level.Info:
                color = ConsoleColor.White;
                break;
            case Logging.Level.Warning:
                color = ConsoleColor.Yellow;
                break;
            case Logging.Level.Error:
                color = ConsoleColor.Red;
                break;
            }
            con.ForegroundColor = color;
            con.Write(item.timestamp);
            con.CustomColorEnabled = false;
            con.WriteLine(item.text);
        }

        private static void TestSocketWrite(Stopwatch sw, IPEndPoint ep, int bufSize, int count)
        {
            NaiveUtils.RunAsyncTask(async () => {
                var socket = await NaiveUtils.ConnectTcpAsync(AddrPort.Parse(ep.ToString()), 5000);
                var stream = new SocketStream1(socket);
                sw.Restart();
                var buf = new byte[bufSize];
                for (int i = 0; i < count; i++) {
                    await stream.WriteAsync(buf);
                }
                socket.Close();
            }).RunSync();
        }

        private static void Speck0Test(byte[] samplekey, int bufSize, int loops, bool allowMultiThreading)
        {
            var ch = new Speck.Ctr128128(samplekey);
            ch.EnableMultiThreading = allowMultiThreading;
            ch.IV = new byte[] { 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80 };
            var buf = new byte[bufSize];
            var bv = new BytesSegment(buf);
            for (int i = 0; i < loops; i++) {
                ch.Update(bv);
            }
        }
    }
}
